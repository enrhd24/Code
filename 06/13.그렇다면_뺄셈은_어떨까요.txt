덧셈과 뺄셈
: 여러 측면에서 상호 보완적인 부분이 있다.
: 연산이 이루어지는 방법에서 약산 차이가 있다.

덧셈 
: 오른쪽에서 왼쪽으로 순서대로 계산해나가는 방식
: 각 자리에 발생한 자리올림수를 다음 자리 숫자들과 같이 더해야 하기 때문이다.

뺄셈 : 자시올림수가 아닌 빌림수가 발행한다.
// 덧셈과 뺄셈은 서로 다른 연산 방식을 가지고 있다.

뺄셈의 트릭 : 빼어지는 수 - 빼는 수 = 두수의 차

9의 보수 : 9로 이루어진 숫자 열에서 어떤 값을 뺀 결과
// 빼는 수를 9의 보수로 하구, 빼어지는 수 - 빼는수(9의보수)
   그러하면, 계살할때, 빌림 과정이 필요하지 않다는 것이다.
-> 10진수에서 뺄셈을 할 때, 9로만 이루어진 숫자열에서 빼는 수를 
   뺐기 때문에 9의 보수라 불렀습니다.

? 이 숫자들을 2진수로 바꾸어볼까요? ?
1의 보수 
: 이진수의 반대 값 속은 역수라 이야기 한다.
: 비트 단위의 반전을 통하여 얻을 수 있다

1. 빼는 수를 1111111에서 뺍니다.
2. 빼는 수에 대한 1의 보수와 빼어지는 수를 더한다.1
3. 결과에 1을 더하고, 100000000을 뺀다.
// 사실 이 방법은 모든 미트를 반전(inverting)시켜서 결과를 얻음.

8비트 가산기
: 덧셈기에서 핵심적인 부분을 논리 게이크로 만들어진다.
: 입력이 각각 입력 스위치와 연결되어 덧셈이 수행되어야 하는 8비트 값을 나타냄.
: 자리 올림 입력은 접지되어 있었다.
: 자리올림 출력은 9번째 전구와 연결되어 있었다는 것도 기억하실 것이다.

오버플러/언더플로
: 연산의 결과가 여덟 개의 전구로도 정상적으로 표시될 수 없는 경우

인버터라고 불리는 신호 8개의 액스오알 게이트
: 8비트의 1의 보수는 8개의 인버터를 통하여 구할 수 있습니다.
  뺄셈의 경우 입력 값이 반전되도록 만들 필요가 있어 액스오알로 만드는 것이 좋다.

SUB 
: 이신호는 것셈과 뺄셈을 선택하는 스위치
: 덧셈기에 들어가기전 모든 비트가 반전된다.
// 오버플로/언더플로를 나타내는 전구는 덧셈기의 
   CO의 출력이 0인 경우 블이 들어와야 함.
-> 빼는 수가 빼어지는 수보다 커져서 결과가 음수가 되는 경우밖에 없다.

0(영)
: 양수와 음수의 중간에 위치하고 있다.
: 양수가 무한히 나열과 음수의 무한히 나열되어 있다고 상상할 수 있음.
// 모든 숫자가 어느 정보 점위 내에 있다고 가정을 해봅시다.
-> 어떠한 음수의 값을 표현하기 위해 1000-음수를 하는 것이다.
-> 이 숫자들이 원형으로 늘어진 형태를 가지고 있다는 것에 관심을 자질 필요.

2의 보수
: 2진수에서 0을 표현하는 동일한 시스템이다.
: 8비트 숫자들을 이용해서 음수를 표현하는 된다.
: 1이 되면 음수를 나타내고, 0인경우에는 양수를 나타낸다.
// 오버플루와 언데플로를 발생시키는 조건에 대래서 주의를 기울리자.

정리 이진수
: 1. 부호가 있는 숫자를 표현가능
: 2. 부호가 없는 숫자를 표현가능
: 2진수 자체만으로 부호가 있는지, 부호가 없는지 판단할 수 없다.
: 이러한 부분이 비트 사용이 어려움이다 
  0과 1만을 나타내며 그 자체로 어떤 것을 나타내는지 않알려준다.
