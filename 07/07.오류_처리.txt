### Content
오류처리
- 뭔가 잘못될 가능성은 늘 존재한다.
- 상당수 코드 기반은 오류 처리 코드에서 좌우된다.
- 실제 코드가 하는 일을 파악하기가 거의 불가능하다.

### 깨끗하고 튼튼한 코드에 한걸음 다가가보자
---

### 오류 코드보다 예외를 사용하자
- 과거 : 오류 플래그를 설정 및 호출자에게 오류 코드를 반환하는 방법
- 현재 : 오류가 발생시 예외를 통해 논리와 오류처리코드가 뒤섞이지 않음
- 이유 : 알고리즘과 분리하여 각 개념을 독립적으로 살쳐보고 이해할 수 있다.

### Try-Catch-Finally 문부터 작성하라
- 이유 : 블록의 이슈가 호출자가 기대하는 상태를 정의하기 쉽다.
- 필수 : try은 트랜잭션, catch은 프로그램 상태 일관성 유지
- 사용 : 코드가 예외를 던질때, 데스트 통과되어 리팩터링이 가능하다.

### 미확인 예외를 사용하라
- 이유 : 안정적인 소프트웨어 제작하는 요소에서는 필요하지 않음
- 이슈 : 확인된 예외는 CCP를 위반하는 건 하위에서 고치면 상위에서 다 고쳐야함.
- 현상 : 환인된 예외가 캡슐화를 깨버리는 현상이 일어난다.


### 예외에 의미를 제공하라
- 사용 : 예외를 던질 대 전후 상황을 충분히 덧붙인다.
- 확인 : 오류 메시지에 정보를 담아 예외와 함께 던진다.
- 정리 : 실패한 연산 이름 및 유형 언급으로 오류기록의 여지를 줌.

### 호출자를 고려해 예외 클래스를 정의하라
- 중요 : 오류를 잡아내는 방법으로 사용되어야 한다.
- 방법 : 오류기록 , 프로그램 수행 여부 조회
- 장점 : 감싸기 클래스로 외부라이브리와 프로그램 사이 의존성이 줄어들어 테스트에 용이하다.
- 여지 : 한 예외를 잡고 다른 예외를 무시해도 관챊으면, 여러 예외 클래스를 사용한다.

### 정상 흐름을 정의하라
- 개요 : 오류 감지가 프로그램 언저리로 밀려나 논리를 다라가지 어렵게 만든다.
- 정의 : 특수사례 패턴 -> 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식
- 정리 : 클래스나 객체가 예외적인 상황을 탭슐화해서 처리하기 때문이다.

### null을 반환하지 마라
- 단점 : 일거리를 늘리고 호출자에게 문제를 떠넘겨 애플리케이션이 통제불능에 빠질 수 있음.
- 사용 : null를 사용하고자 한다면, 예외 및 감사기 메서드를 구현하여 특수 사례 객체를 반환하자.

### null을 전달하지 마라
- 단점 : null을 반환하는 것보다 전달하는 것이 더 나쁘다.
- 이슈 : 문서화로 읽기는 편하지만 문제를 해결하지 못해 실행 오류가 발생한다.
- 대책 : 초기부터 null을 넘기지 못하도록 금지하는 정책이 합리적이다.
- 효과 : 부주의한 실수를 저지를 확률도 작아진다.

---

### 정리의 시간
- 깨끗한 코드는 읽기도 좋고 안정성도 높아야 한다.
- 오류처리와 논리와 독립적인 사안으로 고려해야 한다.
- 독립적인 추론이 가능해지면, 코드 유지보수성도 크게 높아진다.